<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=980, initial-scale=1">
        <title>gen - a generics library for Go</title>
        <meta name="description" content="gen is a tool for adding generics-like functionality to Go, in the style of C#'s Linq or JavaScript's underscore.">
        <meta name="keywords" content="golang generics linq underscore">
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
        <link rel="stylesheet" href="gen.css">
        <link rel="icon" type="image/png" href="gopher.png">
    </head>
    <body>
        <div id="sidebar">
            <nav>
                <h4><a href="#Concepts">Concepts</a></h4>
                <h4><a href="#Quick">Quick start</a></h4>
                <h4><a href="#Usage">Usage</a></h4>
                <h4><a href="#Methods">Standard Methods</a></h4>
                <p class="methods">
                    <a href="#Where">- Where</a>
                    <a href="#Count">- Count</a>
                    <a href="#Any">- Any</a>
                    <a href="#All">- All</a>
                    <a href="#First">- First</a>
                    <a href="#Single">- Single</a>
                    <a href="#Each">- Each</a>
                    <a href="#Sort">- Sort</a>
                    <a href="#Distinct">- Distinct</a>
                    <a href="#DistinctBy">- DistinctBy</a>
                    <a href="#Min">- Min</a>
                    <a href="#Max">- Max</a>
                </p>
                <h4><a href="#Projections">Projection Methods</a></h4>
                <p class="methods">
                    <a href="#Select">- Select</a>
                    <a href="#GroupBy">- GroupBy</a>
                    <a href="#Sum">- Sum</a>
                    <a href="#Average">- Average</a>
                    <a href="#MaxProjection">- Max</a>
                    <a href="#MinProjection">- Min</a>
                    <a href="#Aggregate">- Aggregate</a>
                </p>

                <h4><a href="#Subsetting">Subsetting</a></h4>
                <h4><a href="#FAQ">FAQ</a></h4><br />

                <a href="https://github.com/clipperhouse/gen" id="github">Source</a><br /><br />
                <a href="https://twitter.com/clipperhouse" id="twitter">@clipperhouse</a><br /><br />

                <h4><a href="#Custom" class="strike">Custom Methods</a></h4><br />

            </nav>
        </div>
        <div id="content">
            <a href="https://github.com/DisposaBoy/GoSublime"><img src="completion.png" id="completion"></a>
            <h1>gen <span class="alpha">alpha</span></h1>
            <h3>
                A library for bringing generics-like functionality to Go
            </h3>
            <p>
                gen is an attempt to bring some generics-like functionality to Go, with inspiration from C#’s <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable_methods(v=vs.110).aspx">Linq</a>, JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Methods">Array methods</a> and the <a href="http://underscorejs.org/">underscore</a> library. Operations include filtering, grouping, sorting and more.
            </p>

            <p>The pattern is to pass func’s as you would pass lambdas in Linq or functions in JavaScript.</p>

            <h2 id="Concepts">Concepts</h2>
            <p>gen generates code for your types, at development time, using the command line. gen is not an import; the generated source becomes part of your project and takes no external dependencies.</p>

            <p>You specify which of your types you’d like to generate <a href="#Methods">methods</a> on by marking them up with simple tags.</p>

            <p>A new slice type is generated for the types you specify. We call it the <strong>plural type</strong>. For example, if you gen an existing type Thing, a new plural type will be created:</p>

<pre>
type Things []Thing
</pre>

            <p>…and you’ll use this wherever you would otherwise use a slice.</p>

<pre>
myThings := Things{...}
otherThings := myThings.Where(func).Sort(func)
</pre>
            <h2 id="Quick">Quick start</h2>
            <p>Of course, start by installing Go, <a href="http://golang.org/doc/code.html">setting up paths</a>, etc. Then:</p>

<pre>
go get github.com/clipperhouse/gen
</pre>
            <p>Create a new Go project, and <span class="cmd">cd</span> into it. Create a main.go file and define a type in it.</p>

            <p>Now, mark it up with a simple <span class="cmd">+gen</span> tag in an adjacent comment like so:</p>
<pre>
// +gen
type MyType struct {
    ...
}
</pre>
            <p>And at the command line, simply type</p>
<pre>
gen
</pre>

            <p>You should see a new file, named [your struct]_gen.go. Have a look around. Try out that plural type.</p>

            <h2 id="Usage">Usage</h2>

            <p>If you’d like to generate methods that take pointers instead of value types, add the <span class="cmd">*</span> directive.</p>
<pre>
// +gen *
type MyType struct {
    ...
}
</pre>
            <p>To select only a <a href="#Subsetting">subset</a> of methods, use:</p>
<pre>
// +gen * methods:"Any,Where,Count"
type MyType struct {
    ...
}
</pre>
            <p>(You’ll recognize this as the syntax of  <a href="http://golang.org/pkg/reflect/#StructTag">struct tags</a>.)</p>

            <p>To include <a href="#Projections">projection methods</a>, specify projected types:</p>
            
<pre>
// +gen * projections:"int,OtherType"
type MyType struct {
    ...
}
</pre>

            <h2 id="Methods">Methods</h2>

            <h4>Signatures use the example type *Thing.</h4>

            <h3 id="Where">Where</h3>
            <p>
                Returns a new slice (plural type) whose elements return true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534803(v=vs.110).aspx">Where</a> and JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>.
            </p>
<pre>
func (rcv Things) Where(fn func(*Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
shiny := func(p *Product) bool {
    return p.Manufacturer == "Apple"
}
wishlist := products.Where(shiny)
</pre>

            <h3 id="Count">Count</h3>
            <p>
                Returns an int representing the number of elements which return true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535181(v=vs.110).aspx">Count</a>.
            </p>
<pre>
func (rcv Things) Count(fn func(*Thing) bool) int
</pre>
            <p>Example:</p>

<pre>
countDracula := monsters.Count(func(m *Monster) bool {
    return m.HasFangs()
})
</pre>

            <h3 id="Any">Any</h3>
            <p>
                Returns true if one or more elements returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534972(v=vs.110).aspx">Any</a> or underscore’s <a href="http://underscorejs.org/#some">some</a>.
            </p>
<pre>
func (rcv Things) Any(fn func(*Thing) bool) bool
</pre>
            <p>Example:</p>

<pre>
bueller := func(s *Student) bool {
    return s.IsTruant
}
willBeHijinks := students.Any(bueller)
</pre>

            <h3 id="All">All</h3>
            <p>
                Returns true if every element returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548541(v=vs.110).aspx">All</a> or underscore’s <a href="http://underscorejs.org/#every">every</a>.
            </p>
<pre>
func (rcv Things) All(fn func(*Thing) bool) bool
</pre>
            <p>Example:</p>

<pre>
mustPass := func(t *Thing) bool {
    return !t.IsEternal
}
cliché := things.All(mustPass)
</pre>

            <h3 id="First">First</h3>
            <p>
                Returns first element which returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535050(v=vs.110).aspx">First</a> or underscore’s <a href="http://underscorejs.org/#find">find</a>.
            </p>
<pre>
func (rcv Things) First(fn func(*Thing) bool) (*Thing, error)
</pre>
            <p>Example:</p>

<pre>
come := func(c *Customer) bool {
    return c.IsHere
}
served, err := people.First(come)
</pre>
            <p>Returns error if no elements satisfy the func.</p>

            <h3 id="Single">Single</h3>
            <p>
                Returns unique element which returns true for passed func. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb535118(v=vs.110).aspx">Single</a>.
            </p>
<pre>
func (rcv Things) Single(fn func(*Thing) bool) (*Thing, error)
</pre>
            <p>Example:</p>

<pre>
id := request.Id
byId := func(t *Thing) bool {
    return t.Id == id
}
item, err := things.Single(byId)
</pre>
            <p>Returns error if multiple or no elements satisfy the func.</p>

            <h3 id="Each">Each</h3>
            <p>
                Invokes passed func on every element. Comparable to underscore’s <a href="http://underscorejs.org/#each">each</a>.
            </p>
<pre>
func (rcv Things) Each(fn func(*Thing))
</pre>
            <p>Example:</p>

<pre>
update := func(s *Score) {
    s.Recalc()
}
scores.Each(update)
</pre>

            <h3 id="Sort">Sort</h3>
            <p>
                Returns a new slice (plural type) whose elements are sorted based on a func defining ‘less’. The less func takes two elements, and returns true if the first element is less than the second element. 
            </p>
<pre>
func (rcv Things) Sort(less func(*Thing, *Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
byRank := func(a, b *Player) bool {
    return a.Rank &lt; b.Rank
}
leaderboard := player.Sort(byRank)
</pre>

            <p><strong>SortDesc</strong> works similarly, returning the elements in reverse order. Its implementation negates ‘less’, so is effectively Sort(equalOrGreater).</p>

            <p><strong>IsSorted(Desc)</strong> uses a similar idiom, returning true if the elements are sorted according to the ‘less’ comparer.</p>

            <h3 id="Distinct">Distinct</h3>
            <p>
                Returns a new slice (plural type) representing unique elements. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.distinct(v=vs.110).aspx">Distinct</a> or underscore’s <a href="http://underscorejs.org/#uniq">uniq</a>.
            </p>
<pre>
func (rcv Things) Distinct() Things
</pre>
            <p>Example:</p>

<pre>
snowflakes := hipsters.Distinct()
</pre>

<p>Keep in mind that pointers and values have different notions of <a href="http://golang.org/doc/go1#equality">equality</a>, and therefore distinctness.</p>

            <h3 id="DistinctBy">DistinctBy</h3>
            <p>
                Returns a new slice (plural type) representing unique elements, where equality is defined by a passed func.
            </p>
<pre>
func (rcv Things) DistinctBy(func(*Thing, *Thing) bool) Things
</pre>
            <p>Example:</p>

<pre>
hairstyle := func(a *Fashionista, b *Fashionista) bool {
    a.Hairstyle == b.Hairstyle
}
trendsetters := fashionistas.DistinctBy(hairstyle)</pre>

            <h3 id="Min">Min</h3>
<pre>
func (rcv Things) Min(less func(*Thing, *Thing) bool) (*Thing, error)
</pre>
            <p>Returns the element containing the minimum value, when compared to other elements using a passed func defining ‘less’. Returns an error when invoked on an empty slice, considered an invalid operation.</p>

<p>Example:</p>

<pre>
byPrice := func(a, b *Product) bool {
    return a.Price &lt; b.Price
}
cheapest, err := products.Min(byPrice)
</pre>

            <p>In the case of multiple items being equally minimal, the first such element is returned.</p>

            <h3 id="Max">Max</h3>
<pre>
func (rcv Things) Max(less func(*Thing, *Thing) bool) (*Thing, error)
</pre>
            <p>Returns the element containing the maximum value, when compared to other elements using a passed func defining ‘less’. Returns an error when invoked on an empty slice, considered an invalid operation.</p>

<p>Example:</p>

<pre>
byArea := func(a, b *House) bool {
    return a.Area() &lt; b.Area()
}
roomiest, err := houses.Max(byArea)
</pre>

            <h2 id="Projections">Projections</h2>

            <h4>Projections allow ad-hoc mapping of one type to another.</h4>

            <p>Projections are specified by listing types in a <span class="cmd">projection</span> tag. Here’s a marked-up type and some handy func’s, used in the examples below:</p>
<pre>
+gen projections:"int,string"
type Thing struct { 
    Department string
    Year       int
    Sales      float64
    ...
}

getYear := func(t *Thing) int {
    return t.Year
}

getSales := func(t *Thing) float64 {
    return t.Sales
}
</pre>
            <h3 id="Select">Select</h3>

            <p>Returns a projected slice given a func which maps Thing to {{Type}}. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548891(v=vs.110).aspx">Select</a> or underscore’s <a href="http://underscorejs.org/#map">map</a>.</p>

<p>Example:</p>

<pre>
names := myThings.SelectString(func(t *Thing) string {
    return t.Department
})
// => ["Widgets", "Doodads"]
</pre>

            <h3 id="GroupBy">GroupBy</h3>

            <p>Groups elements into a map keyed by {{Type}}. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534501(v=vs.110).aspx">GroupBy</a> or underscore’s <a href="http://underscorejs.org/#groupBy">groupBy</a>.</p>

<p>Example:</p>

<pre>
report := myThings.GroupByInt(getYear)
// => { "1995": [Thing1, Thing2], "2008": [Thing3, Thing4] }
</pre>

            <h3 id="Sum">Sum</h3>

            <p>Sums over all elements. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb298381(v=vs.110).aspx">Sum</a>.</p>

<p>Example:</p>

<pre>
revenue := myThings.SumFloat64(getSales)
// => 9457846.74
</pre>

            <h3 id="Average">Average</h3>

            <p>Sums over all elements and divides by len(Things). Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb358946(v=vs.110).aspx">Average</a>.</p>

<p>Example:</p>

<pre>
avg := myThings.AverageFloat64(getSales)
// => 30005.74
</pre>

            <h3 id="MaxProjection">Max</h3>

            <p>Selects the largest projected value. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb534962(v=vs.110).aspx">Max</a>.</p>

<p>Example:</p>

<pre>
bigmoney := myThings.MaxFloat64(getSales)
// => 68598.99
</pre>

            <h3 id="MinProjection">Min</h3>

            <p>Selects the least projected value. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548741(v=vs.110).aspx">Min</a>.</p>

<p>Example:</p>

<pre>
earliest := myThings.MinInt(getYear)
// => 1995
</pre>

            <h3 id="Aggregate">Aggregate</h3>

            <p>Iterates over Things, operating on each element while maintaining ‘state’. Comparable to Linq’s <a href="http://msdn.microsoft.com/en-us/library/bb548651(v=vs.110).aspx">Aggregate</a> or underscore’s <a href="http://underscorejs.org/#reduce">reduce</a>.</p>

<p>Example:</p>

<pre>
var join = func(state string, value Thing) string {
    if state != "" {
        state += ", "
    }
    return state + value.Department
}
list := myThings.AggregateString(join)
// => "Sales, Marketing, Finance"
</pre>

            <h2 id="Subsetting">Subsetting</h2>

            <p>By default, all of the above <a href="#Methods">standard methods</a> are created when you <span class="cmd">gen</span> a type. Similarly, all of the above <a href="#Projections">projection methods</a> are generated when you include a <span class="cmd">projections</span> tag.</p>

            <p>If you would prefer only to generate specific methods, you can do so with a <span class="cmd">methods</span> tag.</p>

<pre>
// +gen methods:"Count,Where,Select,GroupBy"
type Thing struct {
    Name  string
    Year  int  
    Sales float64
}
</pre>

            <h2 id="FAQ">FAQ</h2>

            <p>First off: we’re alpha! Caveat emptor. Feedback welcome.</p>

            <h4>Why?</h4>
            <p>Go doesn't (yet) offer generic types, and we are accustomed to many of their use cases. Perhaps you are similarly accustomed, or would find them useful.</p>

            <h4>Code generation, really?</h4>
            <p>Yes. We do it to ensure compile-time safety, and to minimize magic. It’s just code, and you can read it.</p>
            <p>Codegen is not without its risks, we understand. But keep in mind that languages which do support generics are in fact doing <a href="http://msdn.microsoft.com/en-us/library/vstudio/f4a6ta2h(v=vs.110).aspx">something like code generation</a>, so perhaps gen’s approach is not that far out.</p>

            <h4>What’s that <a href="#Concepts">plural type</a> business?</h4>
            <p>gen creates a new slice type for your selected struct(s) because method receivers cannot be slices. It’s clearer and less verbose to type myThings.Where(fn) than package.Where(myThings, fn). Not to mention, the latter wouldn’t work for multiple struct types in the same package.</p>

            <h4>You re-implemented sort?</h4>
            <p>Yes. Go’s <a href="http://godoc.org/sort">sort package</a> requires the fulfillment of three <a href="http://golang.org/pkg/sort/#Interface">interface members</a>, two of which are usually boilerplate. If you want to sort by different criteria, you need to implement multiple ‘alias’ types.</p>
            <p>gen’s <a href="#Sort">Sort</a> requires a single argument defining ‘less’, and no interface implementation. You can call ad-hoc sorts simply by passing a different func.</p>
            <p>gen’s implementation is a strongly-typed port of Go’s <a href="http://golang.org/src/pkg/sort/sort.go">implementation</a>. Performance characteristics should be similar.</p>

            <h4>Could some of this be achieved using reflection or interfaces + type assertions?</h4>
            <p>Perhaps! It’s early days and the focus is on the API and compile-time safety. We’ve no doubt that more idiomatic approaches will reveal themselves.</p>

            <h4>What about imported types?</h4>
            <p>gen doesn’t support imported types, not least because one can’t define methods on them. You might instead create a local ‘alias’ type, something like:</p>

<pre>
type MyType otherPackage.Type

// or...

type MyType struct {
    otherPackage.Type
}
</pre>

            <h4>Why didn’t you implement X method?</h4>
            <p>Most likely:</p>
            <ul>
                <li>We haven’t gotten to it yet, or</li>
                <li>We haven’t found an idiomatic way to do it, or</li>
                <li>It doesn’t save you any code, or</li>
                <li>It duplicates something that Go does well.</li>
            </ul>

            <p>Here are some <a href="https://github.com/clipperhouse/gen#design-principles-for-contributors">design criteria</a>.</p>

            <h4>Can I use it?</h4>
            <p>We’d be thrilled if you would test it out and offer feedback. It’s still early bits, caveat emptor for production use. The API will likely be volatile prior to 1.0.</p>

            <p>Please let us know what you think via <a href="https://github.com/clipperhouse/gen/issues">GitHub issues</a> or ping Matt on Twitter <a href="https://twitter.com/clipperhouse">@clipperhouse</a>.</p>

            <h4>Can I help?</h4>
            <p>Sure, the code is <a href="https://github.com/clipperhouse/gen">here</a>.</p>

            <h4>Who is ‘we’?</h4>
            <p>Matt Sherman, mostly. You can reach him @clipperhouse on <a href="https://github.com/clipperhouse">GitHub</a> or <a href="https://twitter.com/clipperhouse">Twitter</a>. We have are ramping up with <a href="https://github.com/clipperhouse/gen/graphs/contributors">contributors</a> too.</p>

            <h4 id="Custom">What happened to custom methods?</h4>

            <p>They've been deprecated in favor of more-flexible <a href="#Projections">projections</a>. The rationale is <a href="https://github.com/clipperhouse/gen/issues/8">here</a>.</p>
</div>
</body>
</html>

