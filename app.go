package typewriter

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"strings"
	"text/template"
)

// Individual TypeWriters register on init, keyed by name
var typeWriters = make(map[string]TypeWriter)

// Register allows template packages to make themselves known to a 'parent' package, usually in the init() func.
// Comparable to the approach taken by builtin image package for registration of image types (eg image/png).
// Your program will do something like:
//	import (
//		"github.com/clipperhouse/gen/templates"
//		_ "github.com/clipperhouse/gen/templates/projection"
//	)
func Register(tw TypeWriter) {
	if _, exists := typeWriters[tw.Name()]; exists {
		panic(fmt.Errorf("A TypeWriter by the name %s has already been registered", tw.Name()))
	}
	typeWriters[tw.Name()] = tw
}

type App struct {
	// All typewriter.Type found in the current directory.
	Types []Type
	// All typewriter.TypeWriters registered on init.
	TypeWriters map[string]TypeWriter
}

// NewApp parses the current directory, collecting Types and their related information.
func NewApp(directive string) (App, error) {
	var app App

	typs, err := getTypes(directive)
	if err != nil {
		return app, err
	}

	app.Types = typs
	app.TypeWriters = typeWriters
	return app, nil
}

// WriteAll writes the generated code for all Types and TypeWriters in the App to respective files.
func (a App) WriteAll() {
	// Validate them all, don't fail halfway
	for _, t := range a.Types {
		for _, tw := range a.TypeWriters {
			err := tw.Validate(t)
			if err != nil {
				fmt.Println(err) // TODO: return error?
				return
			}
		}
	}

	// one buffer for each file, keyed by file name
	buffers := make(map[string]bytes.Buffer)

	// Validated above, go ahead and write
	for _, t := range a.Types {
		for _, tw := range a.TypeWriters {
			var b bytes.Buffer
			write(&b, t, tw)
			f := strings.ToLower(fmt.Sprintf("%s_%s.go", t.LocalName(), tw.Name()))
			buffers[f] = b
		}
	}

	// validate generated ast's before committing to files
	for filename, buffer := range buffers {
		if _, err := parser.ParseFile(token.NewFileSet(), filename, buffer.String(), 0); err != nil {
			fmt.Println(err) // TODO: return error?
			// TODO: prompt to write _file on error? parsing errors are meaningless without?
			return
		}
	}

	// TODO: format

	for filename, buffer := range buffers {
		writeFile(filename, &buffer)
	}
}

func write(w io.Writer, t Type, tw TypeWriter) {
	io.WriteString(w, `// This file was generated by typewriter

`)
	tw.WriteHeader(w, t)
	packageTmpl.Execute(w, t.Package.Name)
	importsTmpl.Execute(w, tw.Imports(t))
	tw.Write(w, t)
}

func writeFile(filename string, buffer io.Reader) {
	w, err := os.Create(filename)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer w.Close()

	io.Copy(w, buffer)
}

var packageTmpl = template.Must(template.New("package").Parse(`package {{.}}
`))

var importsTmpl = template.Must(template.New("imports").Parse(`{{if gt (len .) 0}}
import ({{range .}}
	"{{.}}"{{end}}
)
{{end}}
`))
